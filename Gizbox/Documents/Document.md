# Gizbox 文档  

## 全局作用域和顶层语句    

支持顶层语句。  

显式定义的顶层变量视作全局变量，存储在静态数据区。顶层临时变量视为局部变量。     


## 栈帧结构  

```  
高地址
+------------------+
| 参数5, 6, 7...    | <- 超出4个参数的部分
+------------------+
| Shadow Space     | <- 32字节（调用者分配）
| (4个8字节槽位)    |
+------------------+
| 返回地址          | <- call指令推入
+------------------+
| 保存的RBP         | <- 被调用者保存
+------------------+
| 保存的其他非易失性 | <- 被调用者保存
| 寄存器            |
+------------------+
| 局部变量          | <- 编译器分配
+------------------+
| 寄存器溢出槽位     | <- 编译器管理
+------------------+
| 对齐填充          | <- 保持16字节对齐
+------------------+ <- RSP指向这里
低地址
```


## 开发日志  

**Prospects**  

操作符重载(代码生成层面 or 解释器层面)    
值类型结构体（需要脚本引擎模拟内存）      
模式匹配（Pattern Matching）  
管道操作符（Pipeline Operator）
解构赋值（Destructuring Assignment）
内置并发支持（Built-in Concurrency Support）
可选链（Optional Chaining）
函数式编程(惰性求值（Lazy Evaluation）、无副作用函数)
函数头等公民  
元编程和宏（类似Lisp和Rust的宏）  
响应式编程原生支持  
借鉴（Haskell、LISP、Prolog、Rust）  

**优化**    

优化外部函数调用效率。使用CreateDelegate？  
使用哈希表优化LALR生成算法。  


**Gizbox TODO**   

处理Mem-Mem问题（在"="等中判断是否是两个内存操作数，需要寄存器中转）  

去掉 and rsp, -16；改为“根据当前 RSP 偏移 + shadow + 栈参数字节数来计算是否需要额外 +8 的对齐修正”，并在 call 之后精确地 add 回同样的字节数（包括 shadow）。

寄存器分配算法（图着色）

在寄存器分配/活跃性之后，计算需要保存/恢复的 caller/callee-saved 寄存器，填充占位。  