# Gizbox 文档  


## 命名空间  

命名空间和全局变量名、类名之间使用`::`分隔，允许嵌套。    
命名空间导入`using XXX`在`import`语句之后、顶层语句之前。   




## 顶层语句和全局作用域    

所有顶层语句隐式放在一个`main`函数中。  
显式定义的顶层变量视作全局变量，存储在静态数据区。顶层临时变量视为局部变量。     





## 库  

代码文件可以编译为库。库文件是一个IR文件。包含IR代码、符号表/作用域、以及常量列表等信息。    
在编译过程中，主编译单元通过`import`导入库文件，编译时库文件和主编译单元各自编译为obj文件，然后链接为可执行文件。  





## 类型    

基础类型：  
`void`、`bool`、`char`、`int`、`long`、`uint`、`ulong`、`float`、`double`    

引用类型：
示例：`MyClass` -`Core::Object`及其派生类。      
示例：`string` -字符串类型。    
示例：`int[]`、`string[]` -数组  




## 类&继承  

注意事项：  
  - 只允许单继承。  
  - 所有成员函数都是虚函数。  
  - 通过`private:`和`public:`标注成员访问权限。如果不标注默认为public。  
  - 类中只能有非静态成员。    
  - 所有类都隐式继承自`Core::Object`。  

示例：  
```
class Creature
{
    void Move(){}
}
class Human : Creature
{
    string name = null;
    void Move(){}
}
```






## 模板  

模板会作为ast节点保存在IR文件中。在第一次使用的编译单元中特化。    

#### 函数模板  

```
T Add<T>(T a, T b)
{
    return a + b;
}
```

#### 类模板  

```
class Container<T>
{
private:
    T[] data;
public:
    void Add(T value)
    {
        //...
    }
}
```




## RTTI    

获取类型的Type对象：  
`typeof(T)`  
获取变量的Type对象：  
`gettype(obj)`



## 所有权（Ownership）

引用类型有三种所有权模型：  
1. Manual:非托管类型。手动管理释放（默认模型）（手动delete释放）  
2. Own:所有权对象（自动释放）  
3. Bor:借用对象（别名引用）   

值类型不支持所有权语义。    

原生数组不支持所有权机制，数组元素也没有所有权，所有权对象和借用对象都不能加入数组。    

所有权转移的3种情形：  
1.赋值  
2.作为函数参数传递（参数类型是own的）  
3.作为函数返回值传递（返回值类型是own的）  

#### 所有权托管的class    

class定义用`own`修饰，则该类型的对象都是所有权系统托管。  

```
class own AAA { }  //所有权系统托管的class类型    
AAA o = new AAA();  //o是所有权系统托管的变量  
```


#### 所有权托管的对象    

对于普通的class类型，其变量声明时可以用`own`关键字显式标记这个对象用所有权系统托管。    

```
class AAA {}  //普通class类型（非所有权系统托管）  
own AAA o = new AAA();  //显式标记为所有权系统托管    
```

#### 所有权转移    

```
own AAA o1 = new AAA();
own AAA o2 = o1;  //所有权转移,o1已变为“已移动”不可再用。    
```
   

#### 对象借用(borrow)  

“借用”变量，仅做别名引用，不能释放、不能逃逸其所借对象的作用域。    

```
bor AAA b = o; //b是对o的借用  
```

借用绑定可变性：借用之间赋值发生的是别名拷贝，支持同时存在多个别名，不存在借用之间的move语义。  

```
own AAA o = new AAA();
bor AAA b1 = o;
bor AAA b2 = b1;  //借用别名拷贝，原借用b1依然可用      
```

#### 参数传递    

可以使用`own`声明所有权转移传递，也可以使用`bor`声明借用传递。    

#### 返回值  
  
返回值是借用类型是，只能来自参数，不能来自局部变量。   

#### 成员字段  

类成员字段也可以是所有权托管类型。

默认禁止直接从成员字段或数组元素 move-out（包括作为返回值或赋值源）。  
要移动字段所有权，请使用 `replace`：  

```
own T old = replace(obj.field, new T());
```

内置函数`replace` 会返回旧值并将字段写入新值；`obj.field` 必须是字段访问。  


#### 注意事项    

不允许"所有权机制管理(own或者bor类型)的变量"与"手动管理释放的变量"互相赋值。  
只有自定义的引用类型（class）支持所有权语义，基础类型不支持（包括string也不支持）。    










## 在Windows64平台的栈帧结构    

```  
高地址
+------------------+
| 参数5, 6, 7...    | <- 超出4个参数的部分
+------------------+
| Shadow Space     | <- 32字节（调用者分配）
| (4个8字节槽位)    |
+------------------+
| 返回地址          | <- call指令推入
+------------------+
| 保存的RBP         | <- 被调用者保存
+------------------+
| 保存的其他非易失性 | <- 被调用者保存
| 寄存器            |
+------------------+
| 局部变量          | <- 编译器分配
+------------------+
| 寄存器溢出槽位     | <- 编译器管理
+------------------+
| 对齐填充          | <- 保持16字节对齐
+------------------+ <- RSP指向这里
低地址
```
