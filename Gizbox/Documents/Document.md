# Gizbox 文档  


## 类型    

基础类型：`void`、`bool`、`char`、`int`、`long`、`float`、`double`。  
引用类型：`Core::Object`及其派生类。    
特殊引用类型：`string`。  


## 类&继承  

- 只允许单继承。  
- 所有函数都是虚函数。  
- 所有成员都是公有的。  
- 类中只能有非静态成员。    



## 全局作用域和顶层语句    

支持顶层语句。所有顶层语句隐式放在一个`main`函数中。  
显式定义的顶层变量视作全局变量，存储在静态数据区。顶层临时变量视为局部变量。     



## 命名空间  

命名空间和全局变量名、类名之间使用`::`分隔，允许嵌套。    
命名空间导入`using XXX`在`import`语句之后、顶级语句之前。   



## 所有权（Ownership）

仅对引用类型生效，值类型无所有权语义。

- 声明
  - `own T x = new T();`：x 为所有权管理对象，作用域结束自动释放；重绑定前自动释放旧值。  
  - `own T owned2 = owned1;`所有权转移（move），`owned1`变为“已移动”不可再用。 
  - `T brw = owned1;`：借用（borrow），`brw`不可逃逸`owned1`的作用域，且不能作为返回值。   
  - `T brw2 = brw1;`：赋值借用（borrow）。      
  - `T x = new T();`：x 为手动管理对象，需要显式 `delete x;`。  
  
- 赋值
  - `owned2 = owned1`：所有权转移（move），源变量变为“已移动”不可再用；目标若已有对象，先隐式释放。  
  - `brw = owned1;`：借用重新绑定。  
  - `brw2 = brw1;`：等号左边的借用brw2重新绑定。    

- 参数传递
  - 形参带 `own`：发生所有权转移。调用后实参若为 `own` 变量，变为“已移动”。
  - 形参不带 `own`：默认借用，函数体内不得 `delete` 该参数。

- delete
  - 仅允许对手动管理对象使用 `delete`。对 `own` 变量使用 `delete` 为错误。



## 在Windows64平台的栈帧结构    

```  
高地址
+------------------+
| 参数5, 6, 7...    | <- 超出4个参数的部分
+------------------+
| Shadow Space     | <- 32字节（调用者分配）
| (4个8字节槽位)    |
+------------------+
| 返回地址          | <- call指令推入
+------------------+
| 保存的RBP         | <- 被调用者保存
+------------------+
| 保存的其他非易失性 | <- 被调用者保存
| 寄存器            |
+------------------+
| 局部变量          | <- 编译器分配
+------------------+
| 寄存器溢出槽位     | <- 编译器管理
+------------------+
| 对齐填充          | <- 保持16字节对齐
+------------------+ <- RSP指向这里
低地址
```


## 开发日志  

**Prospects**  

操作符重载(代码生成层面 or 解释器层面)    
值类型结构体（需要脚本引擎模拟内存）      
模式匹配（Pattern Matching）  
管道操作符（Pipeline Operator）
解构赋值（Destructuring Assignment）
内置并发支持（Built-in Concurrency Support）
可选链（Optional Chaining）
函数式编程(惰性求值（Lazy Evaluation）、无副作用函数)
函数头等公民  
元编程和宏（类似Lisp和Rust的宏）  
响应式编程原生支持  
借鉴（Haskell、LISP、Prolog、Rust）  


**泛型开发**  

使用类型擦除或者模板实现泛型。  

**多线程开发**  

无栈协程实现。  


**优化**    

优化外部函数调用效率。使用CreateDelegate？  
使用哈希表优化LALR生成算法。  


**字符串临时值优化方法**  

1.手动释放（C语言）  
2.栈分配（自动对象）（C++）  
3.作用域内存池。  
4.编译器优化RVO。  
5.所有权（目前最优解）。    

**Gizbox TODO**   

(DONE) own关键字和语法分析。  

声明规则:
	(DONE)全局作用域不能声明own变量。  
	(DONE)局部作用域可以声明own变量，符号表标记为Owner。    
	own变量，作用域结束自动释放；重绑定前自动释放旧值。（IR生成器为每个函数加一个记录表，哪些离开作用域需要释放）    
	

赋值规则：
	own -> own：移动；目标若已持有先销毁；源标记为已移动
	own -> 非own：借用；禁止逃逸（见借用检查）。
	手动 -> own：禁止（潜在双删）。
	new 临时 -> own：允许移动；-> 非own：禁止（悬挂借用）。

参数规则：
	形参 own：调用处移动；被调函数尾部释放。  
	形参非 own：借用；函数内禁止 delete 该形参。

返回值规则：
	函数返回的“引用类型”一律视为所有者值（Owned rvalue），调用者获得所有权 （最简单、安全，且与现有 delete 完全兼容）  
	禁止 return 借用的别名（如非 own 形参、局部/字段的借用），否则会悬垂。
调用点（接收返回值）  
	绑定到 own 变量：移动接收；目标若已有对象先隐式释放。
	绑定到非 own 变量：允许，成为“手动所有者”，需由程序员 delete（保证对旧代码友好）。
	仅作表达式、不绑定：在语句末尾自动释放该临时（避免泄漏）。


delete 规则：
	只允许“手动管理”的引用；对 own 变量 delete 报错；对非引用类型 delete 报错；对非常量表达式 delete 建议限制为 lvalue 引用变量。

编译期检查  
	借用不能赋给带own的目标
	借用不能存入全局/类字段
	借用不能作为返回值
	借用不能逃逸所有者作用域


符号表/类型系统：为变量/形参增加 OwnershipKind { Manual, Owned, Borrowed, Moved }。
代码生成（Win64Target.cs）： 函数尾对 own 形参与本地 owned 变量做统一释放（覆盖所有 return 边）。

