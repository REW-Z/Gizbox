# Gizbox 文档  


## 类型    

基础类型：  
`void`、`bool`、`char`、`int`、`long`、`float`、`double`    

引用类型：
`Core::Object`及其派生类。      
`string`：字符串类型。    


## 类&继承  

注意事项：  
  - 只允许单继承。  
  - 所有成员函数都是虚函数。  
  - 所有成员都是公有的。  
  - 类中只能有非静态成员。    

示例：  
```
class Creature
{
    void Move(){}
}
class Human : Creature
{
    string name = null;
    void Move(){}
}
```


## 命名空间  

命名空间和全局变量名、类名之间使用`::`分隔，允许嵌套。    
命名空间导入`using XXX`在`import`语句之后、顶层语句之前。   


## 顶层语句和全局作用域    

所有顶层语句隐式放在一个`main`函数中。  
显式定义的顶层变量视作全局变量，存储在静态数据区。顶层临时变量视为局部变量。     



## 所有权（Ownership）

仅对一部分引用类型生效，值类型无所有权语义。    

#### 所有权托管的class    

class定义用`own`修饰，则该类型的对象都是所有权系统托管。  

```
class own AAA { }  //所有权系统托管的class类型    
AAA o = new AAA();  //o是所有权系统托管的变量  
```


#### 所有权托管的对象    

对于普通的class类型，其变量声明时可以用`own`关键字显式标记这个对象用所有权系统托管。    

```
class AAA {}  //普通class类型（非所有权系统托管）  
own AAA o = new AAA();  //显式标记为所有权系统托管    
```

#### 所有权转移    

```
own AAA o1 = new AAA();
own AAA o2 = o1;  //所有权转移,o1已变为“已移动”不可再用。    
```
   

#### 对象借用(borrow)  

“借用”变量，仅做别名引用，不能释放、不能逃逸其所借对象的作用域。    

```
bor AAA b = o; //b是对o的借用  
```

借用绑定可变性：借用之间赋值发生的是别名拷贝，支持同时存在多个别名，不存在借用之间的move语义。  

```
own AAA o = new AAA();
bor AAA b1 = o;
bor AAA b2 = b1;  //借用别名拷贝，原借用b1依然可用      
```

#### 参数传递    

可以使用`own`声明所有权转移传递，也可以使用`bor`声明借用传递。    

#### 返回值  
  
返回值不能是借用。只能是own类型或者手动释放类型。    


#### 注意事项    

不允许"所有权机制管理(own或者bor类型)的变量"与"手动管理释放的变量"互相赋值。     


## 在Windows64平台的栈帧结构    

```  
高地址
+------------------+
| 参数5, 6, 7...    | <- 超出4个参数的部分
+------------------+
| Shadow Space     | <- 32字节（调用者分配）
| (4个8字节槽位)    |
+------------------+
| 返回地址          | <- call指令推入
+------------------+
| 保存的RBP         | <- 被调用者保存
+------------------+
| 保存的其他非易失性 | <- 被调用者保存
| 寄存器            |
+------------------+
| 局部变量          | <- 编译器分配
+------------------+
| 寄存器溢出槽位     | <- 编译器管理
+------------------+
| 对齐填充          | <- 保持16字节对齐
+------------------+ <- RSP指向这里
低地址
```


## 踩坑    

为什么函数作用域下每个作用域都需要生命周期管理？  
因为循环中涉及内存分配，如果不以更小粒度做生命周期管理就会内存泄露。  

```
void foo()
{
    while(xxx)
    {
        own AAA a = new AAA();//需要在这里释放a
    }
}
```


## 开发日志  

**Prospects**  

操作符重载(代码生成层面 or 解释器层面)    
值类型结构体（需要脚本引擎模拟内存）      
模式匹配（Pattern Matching）  
管道操作符（Pipeline Operator）  
解构赋值（Destructuring Assignment）  
内置并发支持（Built-in Concurrency Support）  
可选链（Optional Chaining）  
函数式编程(惰性求值（Lazy Evaluation）、无副作用函数)  
函数头等公民    
元编程和宏（类似Lisp和Rust的宏）    
响应式编程原生支持    
借鉴（Haskell、LISP、Prolog、Rust）    


**泛型开发**  

使用类型擦除或者模板实现泛型。  

**多线程开发**  

无栈协程实现。  


**优化**    

优化外部函数调用效率。使用CreateDelegate？  
使用哈希表优化LALR生成算法。  


**字符串临时值优化方法**  

1.手动释放（C语言）  
2.栈分配（自动对象）（C++）  
3.作用域内存池。  
4.编译器优化RVO。  
5.所有权（目前最优解）。    



**Gizbox TODO**   
